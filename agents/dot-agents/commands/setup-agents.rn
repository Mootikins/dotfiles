/**
Setup script for AI agent compatibility

Creates symlinks from various agent directories to .agents for cross-platform
AI agent integration with the Crucible project.

This script handles:
1. Global dotfiles structure (~/dotfiles/agents/)
2. Project-specific structure (~/crucible/.agents/)
3. Home directory symlinks (~/.agents/)
4. Cross-platform compatibility with fallbacks

Architecture:
- Global: ~/dotfiles/agents/dot-{agent}/ -> ~/dotfiles/agents/dot-agents/
- Project: ~/crucible/.{agent}/ -> ~/crucible/.agents/
- Home: ~/.agents/{agent}/ -> ~/crucible/.agents/

Agent Mappings:
- claude: commands->commands, config->config, contexts->contexts, tools->tools, workflows->workflows
- crush: commands->commands, config->config, contexts->contexts, tools->tools, workflows->workflows
- cursor: commands->commands, config->config, contexts->contexts, tools->tools, workflows->workflows, rules->commands
*/

use std::env;
use std::fs;
use std::os::unix::fs as unix_fs;
use std::path::{Path, PathBuf};
use std::process::Command;

// Agent directory mappings: agent -> [(agent_dir, global_dir), ...]
const AGENT_MAPPINGS: &[(&str, &[(&str, &str)])] = &[
    ("claude", &[
        ("commands", "commands"),
        ("config", "config"),
        ("contexts", "contexts"),
        ("tools", "tools"),
        ("workflows", "workflows"),
    ]),
    ("crush", &[
        ("commands", "commands"),
        ("config", "config"),
        ("contexts", "contexts"),
        ("tools", "tools"),
        ("workflows", "workflows"),
    ]),
    ("cursor", &[
        ("commands", "commands"),
        ("config", "config"),
        ("contexts", "contexts"),
        ("tools", "tools"),
        ("workflows", "workflows"),
        ("rules", "commands"),  // Cursor uses 'rules' for commands
    ]),
];

struct AgentSetup {
    project_root: PathBuf,
    global_agents_root: PathBuf,
    project_agents: PathBuf,
    global_dot_agents: PathBuf,
    home_agents: PathBuf,
    is_windows: bool,
}

impl AgentSetup {
    fn new(project_root: Option<PathBuf>, global_agents_root: Option<PathBuf>) -> Self {
        let project_root = project_root.unwrap_or_else(|| {
            // Default to crucible project
            PathBuf::from(env::var("HOME").unwrap_or_else(|_| "/home/moot".to_string()))
                .join("crucible")
        });

        let global_agents_root = global_agents_root.unwrap_or_else(|| {
            // Default to dotfiles agents
            PathBuf::from(env::var("HOME").unwrap_or_else(|_| "/home/moot".to_string()))
                .join("dotfiles").join("agents")
        });

        let project_agents = project_root.join(".agents");
        let global_dot_agents = global_agents_root.join("dot-agents");
        let home_agents = PathBuf::from(env::var("HOME").unwrap_or_else(|_| "/home/moot".to_string()))
            .join(".agents");

        let is_windows = env::consts::OS == "windows";

        Self {
            project_root,
            global_agents_root,
            project_agents,
            global_dot_agents,
            home_agents,
            is_windows,
        }
    }

    fn create_symlink(&self, target: &Path, link: &Path) -> Result<(), String> {
        // Create symlink if target doesn't exist, with cross-platform fallbacks

        // Check if link exists and is not a symlink
        if link.exists() && !link.is_symlink() {
            return Err(format!("Warning: {} exists and is not a symlink. Skipping.", link.display()));
        }

        // Check if symlink already exists
        if link.is_symlink() {
            println!("âœ… {} already exists", link.display());
            return Ok(());
        }

        // Create parent directory if it doesn't exist
        if let Some(parent) = link.parent() {
            if let Err(e) = fs::create_dir_all(parent) {
                return Err(format!("Failed to create parent directory {}: {}", parent.display(), e));
            }
        }

        if self.is_windows {
            // Windows: try to create symlink, fallback to copy if fails
            match unix_fs::symlink(target, link) {
                Ok(_) => {
                    println!("âœ… Created symlink: {} -> {}", link.display(), target.display());
                    Ok(())
                }
                Err(_) => {
                    // Fallback: copy files/directories
                    println!("ðŸ“‹ Windows fallback: copying {} to {}", target.display(), link.display());
                    if target.is_dir() {
                        self.copy_dir_recursive(target, link)?;
                    } else {
                        fs::copy(target, link).map_err(|e| format!("Failed to copy file: {}", e))?;
                    }
                    Ok(())
                }
            }
        } else {
            // Unix systems: create relative symlink
            let rel_path = pathdiff::diff_paths(target, link.parent().unwrap())
                .ok_or_else(|| "Could not compute relative path".to_string())?;

            unix_fs::symlink(&rel_path, link)
                .map_err(|e| format!("Failed to create symlink: {}", e))?;
            println!("âœ… Created symlink: {} -> {}", link.display(), rel_path.display());
            Ok(())
        }
    }

    fn copy_dir_recursive(&self, src: &Path, dst: &Path) -> Result<(), String> {
        if !dst.exists() {
            fs::create_dir_all(dst)
                .map_err(|e| format!("Failed to create directory {}: {}", dst.display(), e))?;
        }

        for entry in fs::read_dir(src)
            .map_err(|e| format!("Failed to read directory {}: {}", src.display(), e))?
        {
            let entry = entry.map_err(|e| format!("Failed to read entry: {}", e))?;
            let file_type = entry.file_type().map_err(|e| format!("Failed to get file type: {}", e))?;
            let src_path = entry.path();
            let dst_path = dst.join(entry.file_name());

            if file_type.is_dir() {
                self.copy_dir_recursive(&src_path, &dst_path)?;
            } else {
                fs::copy(&src_path, &dst_path)
                    .map_err(|e| format!("Failed to copy {} to {}: {}", src_path.display(), dst_path.display(), e))?;
            }
        }
        Ok(())
    }

    fn cleanup_global_agents(&self) {
        println!("ðŸ§¹ Cleaning up global agent directories...");

        for (agent, _) in AGENT_MAPPINGS.iter() {
            let agent_dir = self.home_agents.join(agent);
            if agent_dir.exists() {
                println!("  Removing {} directory from global system", agent);
                if let Err(e) = fs::remove_dir_all(&agent_dir) {
                    println!("  Failed to remove {}: {}", agent, e);
                }
            }
        }
    }

    fn create_global_symlinks(&self) {
        println!("ðŸ”— Creating global symlinks...");

        for (agent, mappings) in AGENT_MAPPINGS.iter() {
            println!("  Creating symlinks for {}...", agent);
            let agent_root = self.global_agents_root.join(format!("dot-{}", agent));

            for (agent_dir, global_dir) in mappings.iter() {
                let target = self.global_dot_agents.join(global_dir);
                let link_path = agent_root.join(agent_dir);

                if let Err(e) = self.create_symlink(&target, &link_path) {
                    println!("    Failed to create symlink {} -> {}: {}",
                        link_path.display(), target.display(), e);
                } else {
                    println!("    {} -> {}", agent_dir, target.display());
                }
            }
        }
    }

    fn create_project_symlinks(&self) {
        println!("ðŸ”— Creating project symlinks...");

        for (agent, mappings) in AGENT_MAPPINGS.iter() {
            println!("  Creating symlinks for {} in project...", agent);
            let agent_root = self.project_root.join(format!(".{}", agent));

            for (agent_dir, global_dir) in mappings.iter() {
                let target = self.project_agents.join(global_dir);
                let link_path = agent_root.join(agent_dir);

                if let Err(e) = self.create_symlink(&target, &link_path) {
                    println!("    Failed to create symlink {} -> {}: {}",
                        link_path.display(), target.display(), e);
                } else {
                    println!("    {} -> {}", agent_dir, target.display());
                }
            }
        }
    }

    fn create_home_symlinks(&self) {
        println!("ðŸ  Creating home directory symlinks...");

        // Ensure home agents directory exists
        if let Err(e) = fs::create_dir_all(&self.home_agents) {
            println!("  Failed to create home agents directory: {}", e);
            return;
        }

        // Create symlinks to project .agents for each agent
        for (agent, _) in AGENT_MAPPINGS.iter() {
            let agent_link = self.home_agents.join(agent);

            if let Err(e) = self.create_symlink(&self.project_agents, &agent_link) {
                println!("  Failed to create home symlink for {}: {}", agent, e);
            } else {
                println!("  ~/.agents/{} -> {}", agent, self.project_agents.display());
            }
        }
    }

    fn setup(&self) {
        println!("ðŸ¤– Setting up AI agent compatibility for Crucible project");
        println!("  Project root: {}", self.project_root.display());
        println!("  Global agents root: {}", self.global_agents_root.display());
        println!("  Project agents: {}", self.project_agents.display());
        println!("  Platform: {}", env::consts::OS);

        self.cleanup_global_agents();
        self.create_global_symlinks();
        self.create_project_symlinks();
        self.create_home_symlinks();

        println!("");
        println!("ðŸŽ‰ AI agent setup complete!");
        println!("");
        println!("Available agents can now access Crucible's AI tools at:");
        for agent in ["cursor", "claude", "crush"] {
            println!("  - .{}/ (with commands in .{}/commands/)", agent, agent);
        }
        println!("  - And more...");
        println!("");
        println!("Commands available:");
        println!("  - review-code.md - Code review and quality analysis");
        println!("  - write-tests.md - Generate comprehensive tests");
        println!("  - refactor-code.md - Refactor following project patterns");
        println!("  - analyze-architecture.md - Architecture analysis");
        println!("  - generate-docs.md - Generate documentation");
        println!("");
        println!("To add a new agent, edit the AGENT_MAPPINGS constant in this script.");
    }
}

fn main() {
    let args: Vec<String> = env::args().collect();

    let project_root = args.get(1).map(|s| PathBuf::from(s));
    let global_agents_root = args.get(2).map(|s| PathBuf::from(s));

    let setup = AgentSetup::new(project_root, global_agents_root);
    setup.setup();
}

#[test]
fn test_agent_mappings_structure() {
    // Test that our mappings are correct
    let claude_mappings = AGENT_MAPPINGS.iter()
        .find(|(agent, _)| *agent == "claude")
        .unwrap().1;

    assert_eq!(claude_mappings.len(), 5);

    let cursor_mappings = AGENT_MAPPINGS.iter()
        .find(|(agent, _)| *agent == "cursor")
        .unwrap().1;

    assert_eq!(cursor_mappings.len(), 6);

    // Verify cursor has the rules -> commands mapping
    let has_rules_mapping = cursor_mappings.iter()
        .any(|(agent_dir, global_dir)| agent_dir == &"rules" && global_dir == &"commands");

    assert!(has_rules_mapping);
}

#[test]
fn test_setup_initialization() {
    // Test that AgentSetup can be initialized
    let setup = AgentSetup::new(None, None);

    assert!(setup.project_root.exists() || setup.project_root.ends_with("crucible"));
    assert!(setup.global_agents_root.ends_with("dotfiles/agents"));
}

#[test]
fn test_path_construction() {
    // Test path construction logic
    let project_root = PathBuf::from("/test/crucible");
    let global_root = PathBuf::from("/test/dotfiles/agents");

    let setup = AgentSetup::new(Some(project_root.clone()), Some(global_root.clone()));

    assert_eq!(setup.project_agents, project_root.join(".agents"));
    assert_eq!(setup.global_dot_agents, global_root.join("dot-agents"));
    assert_eq!(setup.home_agents, PathBuf::from("/home/moot/.agents")); // Default
}